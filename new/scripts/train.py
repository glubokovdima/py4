# scripts/train.py

import argparse
import sys
import os
import logging

# Ensure the src directory is in the Python path if necessary (usually handled by running from project root)
# sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../src')))

# Import config and logging setup first
from src.utils.config import get_config
from src.utils.logging_setup import setup_logging

# Import the main training function
from src.models.train import train_models_for_group_or_symbol

# --- Initial Setup ---
# Load configuration
config = get_config()
SYMBOL_GROUPS = config['symbol_groups'] # Need symbol groups for validation

# Configure logging for this script
setup_logging()
logger = logging.getLogger(__name__) # Use logger specific to this module


# --- Command Line Interface ---

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π CatBoost –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞ –∏ —Å–∏–º–≤–æ–ª–∞/–≥—Ä—É–ø–ø—ã.")
    parser.add_argument('--tf', type=str, required=True, help="–¢–∞–π–º—Ñ—Ä–µ–π–º –¥–ª—è –æ–±—É—á–µ–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä: 1m, 5m).")

    # Mutually exclusive group for specifying symbol or group
    symbol_group = parser.add_mutually_exclusive_group(required=True)
    symbol_group.add_argument('--symbol', type=str, help="–û–±—É—á–∏—Ç—å –º–æ–¥–µ–ª—å –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: BTCUSDT).")
    symbol_group.add_argument('--symbol-group', type=str, help="–û–±—É—á–∏—Ç—å –º–æ–¥–µ–ª—å –¥–ª—è –ø—Ä–µ–¥–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –≥—Ä—É–ø–ø—ã —Å–∏–º–≤–æ–ª–æ–≤ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: top8, meme).")
    # Note: Training a model on *all* symbols requires preprocess.py to generate features_all_{tf}.pkl
    # and then you would typically call this script with a specific key like '--symbol-group all'
    # or handle 'all' as a special case key in the CLI parsing if it's not a symbol group.
    # Let's allow 'all' as a valid key for --symbol-group for now, distinct from actual groups.


    args = parser.parse_args()

    # Determine the key for the training process (used for filenames and context)
    # This key should match the suffix used when features were generated by preprocess.py
    symbol_or_group_key = None
    if args.symbol_group:
        group_name = args.symbol_group.lower()
        # Allow the special key 'all' or validate against known groups
        if group_name == 'all':
             symbol_or_group_key = 'all'
             logger.info("–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –¥–ª—è –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ñ–∞–π–ª features_all_{tf}.pkl).")
        elif group_name in SYMBOL_GROUPS:
            symbol_or_group_key = group_name
            logger.info(f"–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –¥–ª—è –≥—Ä—É–ø–ø—ã '{group_name}'.")
        else:
            logger.error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –≥—Ä—É–ø–ø–∞ —Å–∏–º–≤–æ–ª–æ–≤: {args.symbol_group}. –î–æ—Å—Ç—É–ø–Ω—ã–µ –≥—Ä—É–ø–ø—ã: {list(SYMBOL_GROUPS.keys())} –∏–ª–∏ 'all'.")
            sys.exit(1)
    elif args.symbol:
        symbol_or_group_key = args.symbol.upper() # Ensure symbol key is uppercase
        logger.info(f"–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –¥–ª—è —Å–∏–º–≤–æ–ª–∞: {symbol_or_group_key}.")

    if not symbol_or_group_key:
        # This case should be caught by required=True in the argument group, but as a safeguard
        logger.error("–ù–µ —É–∫–∞–∑–∞–Ω –Ω–∏ --symbol, –Ω–∏ --symbol-group.")
        sys.exit(1)


    # --- Run the training process ---
    try:
        # Call the main training function from the models module
        train_models_for_group_or_symbol(args.tf, symbol_or_group_key)

    except KeyboardInterrupt:
        logger.warning(f"\n–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π –¥–ª—è {symbol_or_group_key} –Ω–∞ {args.tf} –ø—Ä–µ—Ä–≤–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º (Ctrl+C).")
        sys.exit(130) # Standard Unix exit code for Ctrl+C
    except Exception as e:
        logger.error(f"üí• –ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—É—á–µ–Ω–∏–∏ –º–æ–¥–µ–ª–µ–π –¥–ª—è {symbol_or_group_key} –Ω–∞ {args.tf}: {e}", exc_info=True)
        sys.exit(1) # Standard Unix exit code for general error